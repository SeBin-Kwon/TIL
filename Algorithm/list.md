# 🗳 리스트(List)

## 1. 배열 vs 연결리스트

### 배열 (Array)

> 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조
>
> 파이썬의 리스트는 배열과 비슷함

- 인덱스(Index)를 통해 데이터에 빠르게 접근
- 배열의 길이는 변경 불가능
  - 길이를 변경하고 싶다면 새로 생성
- 데이터 타입은 고정

<br>

### 연결 리스트 (Linked List)

> 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조

- 맨 처음 노드부터 순차적으로 탐색
- 연결리스트의 길이 자유롭게 변경 가능
  - 삽입, 삭제가 편리
- 다양한 데이터 타입 저장
- 데이터가 메모리에 연속적으로 저장되지 않음

<br>

## 2. 파이썬의 리스트

> 배열의 `인덱스 접근` + 연결리스트의 `가변 길이` => 파이썬의 리스트 (List)

### 파이썬 리스트의 메서드

- `.append(원소)` => `O(1)`

  리스트 맨 끝에 새로운 원소 **삽입**

  - return 값이 없음

- `.pop(인덱스)` => `O(1)`

  특정 인덱스에 있는 원소를 **삭제 및 반환**

  - return 값이 있음. 따로 할당할 수 있음.

> 이미 각각의 메모리 주소를 알기 때문에 n번 계산할 필요가 없음.
>
> `stack`과 같은 구조

- `.count(원소)` => `O(N)`

  리스트에서 해당 원소의 **개수**를 반환

- `.index(원소)` => `O(N)`

  리스트에서 처음으로 원소가 등장하는 **인덱스** 반환

- `.sort()` => `O(N)`

  - 리스트를 오름차순으로 **정렬**
  - `reverse = True` 옵션을 통해 내림차순으로 정렬 가능
  - 리턴 값이 없기 때문에 변수에 따로 저장해도 `None`이 출력

- `.reverse()` => `O(N)`

  리스트의 원소들의 순서를 거꾸로 **뒤집기**

<br>

### 리스트 관련 내장함수

- `len(iterable)` => `O(1)`
  - 리스트의 **길이**(원소의 개수)를 반환
  - 할당된 공간을 이미 알기 때문에 n번 계산할 필요가 없음.
- `sum(iterable)` => `O(N)`
  - 리스트의 모든 원소의 **합**을 반환
- `max(iterable)` => `O(N)`
  - 리스트의 원소 중 **최대값**을 반환
- `min(iterable)` => `O(N)`
  - 리스트의 원소 중 **최소값**을 반환
- `sorted(iterable)` => `O(NlogN)`
  - 오름차순으로 정렬된 새로운 리스트 반환
    - 변수에 새로 할당해서 출력해야함
  - 원본 리스트는 변화 없음
  - 리스트 2개를 메모리에 저장하기 때문에 `.sort()` 보다는 공간을 좀 더 차지함.
- `reversed(iterable)` => `O(N)`
  - 리스트의 순서를 거꾸로 뒤집은 새로운 객체 반환 원본 리스트는 변화 없음

<br>

## 리스트 컴프리헨션 (List Comprehension)

> 코드 **한 줄**만으로 새로운 리스트를 만드는 방법

```python
numbers = []
for i in range(5):
    numbers.append(i)
print(numbers)
# [0, 1, 2, 3, 4]

# 리스트 컴프리헨션
numbers = [i for i in range(5)]
print(numbers)
# [0, 1, 2, 3, 4]

# if문으로 필터링도 가능
odd_numbers = [i for i in range(10) if i % 2 == 1]
print(odd_numbers)
# [1, 3, 5, 7, 9]
```
# 🪜 깊이우선탐색 (DFS)

## 1. 그래프 탐색 알고리즘

> 시작 정점에서 **간선을 타고 이동할 수 있는 모든 정점을 찾는** 알고리즘

- 데이터 구조 => 알고리즘에 활용
- 그래프 데이터 구조 => **탐색 알고리즘**에 활용

<br>

### 그래프 탐색 알고리즘 종류

1. `깊이우선탐색 (DFS)`
   - **스택** + 그래프
     - 들어갔다가 다시 나와야하기 때문
2. `너비우선탐색 (BFS)`
   - **큐** + 그래프
     - 순서대로 쭉 봐야하기 때문

<br>

### 깊이우선탐색 (DFS) vs 너비우선탐색 (BFS)

![images_vagabondms_post_037c243c-108a-49c6-ae6a-abb3673532ca_image-1](dfs.assets/images_vagabondms_post_037c243c-108a-49c6-ae6a-abb3673532ca_image-1.png)

> 산 정상과 가장 가까운 사람을 찾을 땐 BFS가 좋다.

<br>

## 2. 깊이우선탐색 (Depth-First-Search, DFS)

> 시작 정점으로부터 **갈 수 있는 하위 정점까지 가장 깊게 탐색** 하고, 더 이상 갈 곳이 없다면 마지막 갈림길로 돌아와서 다른 정점을 탐색하며 결국 모든 정점을 방문하는 순회 방법

- 미로 탈출로 생각하면 이해하기 쉽다.
  - **어느 한 쪽 길로 가장 깊게 들어갔다가 막히면 다시 돌아와서 다른 길을 탐색한다.**

<br>

### 깊이우선탐색 (DFS)의 특징

- **모든 정점을 방문**할 때 유리하다. 따라서 **경우의 수**, **순열과 조합** 문제에서 많이 사용한다.
- 너비우선탐색(BFS)에 비해 코드 구현이 간단하다.
- 단, **모든 정점을 방문할 필요가 없거나 최단 거리를 구하는 경우**에는 **너비우선탐색(BFS)** 이 유리하다.

<br>

## 3. DFS의 동작 과정

- DFS를 하기 전에, 일단 탐색을 진행할 그래프가 필요하다.

  - 그래프는 **인접 행렬** 혹은 **인접 리스트** 방식으로 표현할 수 있다.

    - 인접 리스트를 더 추천함

    - ```python
      graph = [ [1, 2], [0, 3, 4], [0, 4, 5], [1], [1, 2, 6], [2], [4] ]
      ```

- **각 정점을 방문했는지 여부를 판별**할 방문 체크 리스트가 필요하다.

  - 사람과 달리 컴퓨터는 각 정점에 방문했는지 여부를 알 수 없다.

    따라서 visited 리스트를 따로 선언하여 각 정점을 방문했는지 체크한다.

    - ```python
      visited = [False] * n # n은 정점의 개수
      ```

    - 인덱스는 각 정점의 번호, 방문한 정점은 True, 방문하지 않은 정점은 False

- 왔던 길을 다시 되돌아갈 때, 스택을 활용한다.

<br>

### DFS의 사이클

1. 현재 정점 방문처리
2. 인접한 모든 정점 확인
3. 방문하지 않은 인접 정점 이동

<br>

## 4. DFS의 구현 방식

> **인접 리스트** 로 표현한 그래프 기준, 반복문을 이용한 DFS

- DFS는 직전에 방문한 정점으로 차례로 돌아가야 하므로, 후입선출(LIFO)구조의 **스택**을 사용한다.

```python
visited = [False] * n # 방문 처리 리스트 만들기

def dfs(start):
    stack = [start] # 돌아갈 곳을 기록 
    visited[start] = True # 시작 정점 방문 처리
    while stack: # 스택이 빌 때까지(돌아갈 곳이 없을때까지) 반복 
        cur = stack.pop() # 현재 방문 정점(후입선출)
        for adj in graph[cur]: # 인접한 모든 정점에 대해 
            if not visited[adj]: # 아직 방문하지 않았다면
                visited[adj] = True # 방문 처리   
                stack.append(adj) # 스택에 넣기
dfs(0) # 0번 정점에서 시작
```

<br>

## 5. DFS 문제 풀이

> 문제에서 인덱스가 1부터 시작하기 때문에 n+1을 해준다. 인덱스 0번째는 그냥 비어있게 된다.

```python
visited = [False] * n

def dfs(start):
    stack = [start] 
    visited[start] = True
    
    while stack:
        cur = stack.pop()
        
        for adj in graph[cur]: 
            if not visited[adj]:
                visited[adj] = True
                stack.append(adj)
dfs(1) # 1번 정점에서 시작
```
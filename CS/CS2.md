## 인코딩

비부호형 인코딩: 전통적인 이진수 표시를 사용, 0 이상의 수를 표시

2의 보수 인코딩: 양수 또는 음수 값을 부호형 정수를 표시

부동소수점 인코딩: 2진수 버전의 소수를 표시

### 오버 플로우

컴퓨터는 하나의 수를 인코딩하기 위해 제한된 개수의 비트를 사용하는데 어떤 연산의 결과값이 표시할 수 없을 정도로 클 때 발생함.

부동소수점 연산 -> 오버플로우인 경우 +♾️ 값, 수의 제한된 정밀도 때문에 교환법칙 성립x

정수 표현: 비교적 작은 범위의 값을 매우 정밀하게 인코딩

부동소수점 표시: 넓은 범위의 값을 근사값으로 인코딩



## 2.1 정보의 저장

> 메모리에서 주소지정이 가능한 최소단위 8비트 단위의 블록 **바이트**를 사용

가상메모리 -> 거대한 바이트의 배열로 취급

가상 주소공간: 메모리의 각 바이트는 주소로 식별, 모든 가능한 주소들의 집합

프로그램 객체(데이터, 인스트럭션, 제어정보 등) 관리기법들(저장, 할당 등)은 모두 가상 주소공간 내에서 수행



### 16진수 표시

비트패턴을 0~9, A~F를 사용해 16개의 가능한 값을 나타냄



### 데이터 크기

> 모든 컴퓨터는 워드 크기를 규격으로 가짐

하나의 가상주소 -> 한 개의 워드로 인코딩

이 워드 크기가 결정하는 가장 중요한 시스템 변수: 가상 주소공간의 최대 크기



### 주소지정과 바이트 순서

멀티 바이트 객체는 연속된 바이트에 저장, 객체의 주소는 사용된 바이트의 최소 주소로 정함.



### 바이트 정렬

리틀 엔디안: 가장 덜 중요한 바이트부터 저장

빅 엔디안: 가장 중요한 바이트부터 저장

특정 운영체제가 결정되면 바이트 순서는 고정됨.

IOS는 리틀 엔디안 모드로만 동작



### 스트링

> null 문자로 종료하는 문자열로 인코딩

ASCII 문자코드로 인코딩 



### 부울 대수

> 이진수 값 1과 0을 논리값 TRUE와 FALSE로 인코딩

유한집합을 표시하는데에도 사용 가능



### 비부호형과 부호형 간의 변환

캐스팅(형 변환)

부호형을 비부호형으로 묵시적인 타입 변환을 하면 버그가 발생할 수 있다.

C 이외의 다른 언어들은 비부호형 unsigned 정수를 지원하지 않음



### 부동소수점

> V = x * 2^y 형태의 소수를 인코딩

매우 큰 수와 관련된 계산 또는 0에 매우 가까운 수를 계산할 때, 실수 산술연산의 근사값으로 유용



